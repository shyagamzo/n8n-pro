# Decision Record: Index and README File Patterns

## Context

As the codebase grew, `index.ts` files became difficult to navigate. Finding specific implementations required searching through many "index" results in Ctrl+P, making it hard to locate the actual code. Similarly, README files became comprehensive documentation dumps rather than useful entry points.

This violated the principle of "files should be discoverable by their name" and made the codebase harder to navigate.

## Decision

### Index Files (index.ts)

**INDEX FILES SHOULD ONLY EXPORT PUBLIC API - NEVER CONTAIN CODE**

#### Rules

1. **Exports Only**: `index.ts` files should only contain `export` statements
2. **No Implementation**: Never put classes, functions, or logic in index files
3. **Entry Points**: Entry point index files (background/index.ts, content/index.ts) may import for side effects
4. **Documentation**: Include brief comment describing the module's public API

#### Pattern

```typescript
/**
 * [Module Name] - Public API
 * 
 * [Brief description of what this module provides]
 * See ./[implementation-file].ts for implementation.
 */

export { MainClass, helperFunction } from './implementation-file'
export type { PublicType, Options } from './implementation-file'
```

#### Examples

**✅ GOOD - Exports only:**
```typescript
// lib/orchestrator/index.ts
/**
 * ChatOrchestrator - Public API
 * 
 * Multi-agent orchestrator for n8n workflow creation.
 * See ./orchestrator.ts for implementation.
 */

export { ChatOrchestrator, orchestrator } from './orchestrator'
export type { OrchestratorInput, StreamTokenHandler } from './orchestrator'
```

**✅ GOOD - Entry point with side effects:**
```typescript
// content/index.ts
/**
 * Content Script Entry Point
 * 
 * Injects the n8n Assistant trigger button and chat panel.
 * See ./content-script.ts for implementation.
 */

import './content-script'
```

**❌ BAD - Code in index:**
```typescript
// lib/orchestrator/index.ts
export class ChatOrchestrator {
  // 300 lines of implementation...
}
```

### README Files (README.md)

**README FILES SHOULD BE SUMMARIES WITH REFERENCES - NOT COMPREHENSIVE DOCS**

#### Rules

1. **Brief Overview**: Provide a quick introduction (2-3 paragraphs max)
2. **Quick Start**: Include minimal usage example
3. **Reference Links**: Link to detailed documentation files
4. **Key Features**: Bullet list of main capabilities
5. **See Also**: Link to related files and implementation

#### Pattern

```markdown
# [Module Name]

[Brief description - what it does and why it exists]

## Quick Start

```typescript
[Minimal usage example]
```

## Documentation

- **[Topic 1](./topic-1.md)** - Description
- **[Topic 2](./topic-2.md)** - Description

## Key Features

- Feature 1
- Feature 2
- Feature 3

## See Also

- [implementation.ts](./implementation.ts) - Implementation
- [index.ts](./index.ts) - Public API
```

#### Examples

**✅ GOOD - Summary with references:**
```markdown
# Loom Protocol

**Loom** is a lightweight, indentation-based protocol for structured data transmission between AI agents. It achieves ~40-60% token reduction compared to JSON.

## Quick Start

```typescript
import { parse, format } from './loom';
const result = parse(text);
```

## Documentation

- **[Protocol Specification](./loom-protocol.md)** - Syntax, examples, token efficiency
- **[API Reference](./loom-api.md)** - Complete API documentation
- **[Best Practices](./loom-best-practices.md)** - Usage guidelines
```

**❌ BAD - Everything in README:**
```markdown
# Loom Protocol

[266 lines of comprehensive documentation covering syntax, API, examples, best practices, performance, limitations, future enhancements...]
```

### Documentation Organization

When a README grows too large, extract content into focused files:

**Documentation Types:**
- **Specifications**: Protocol details, syntax, formats (`protocol.md`, `specification.md`)
- **API Reference**: Function signatures, parameters, types (`api.md`, `api-reference.md`)
- **Guides**: How-to, best practices, patterns (`best-practices.md`, `guidelines.md`)
- **Structure**: Organization, architecture (`structure.md`, `architecture.md`)

**Naming Conventions:**
- Use descriptive, specific names: `loom-api.md` not `api.md`
- Prefix with module name for context: `loom-protocol.md`, `prompt-structure.md`
- Use kebab-case: `authoring-guidelines.md` not `AuthoringGuidelines.md`
- Avoid generic names: `best-practices.md` not `docs.md`

## Implementation Details

### Refactoring Process

When refactoring existing code/docs:

1. **Create implementation file**: Extract code to descriptive filename
2. **Update index**: Replace code with exports
3. **Extract docs**: Split README into focused files
4. **Update README**: Rewrite as summary with links
5. **Verify imports**: Build to ensure nothing broke
6. **Commit atomically**: Separate commits for each module

### File Naming

Implementation files should use descriptive names that indicate what they contain:

- `orchestrator.ts` - ChatOrchestrator class
- `prompt-loader.ts` - Prompt loading utilities
- `client.ts` - N8N API client
- `content-script.ts` - Content script logic
- `background-worker.ts` - Service worker implementation

**Avoid:**
- `utils.ts`, `helpers.ts` - Too generic
- `main.ts`, `core.ts` - Not descriptive enough
- Repeating directory name: `orchestrator/orchestrator-manager.ts` → `orchestrator/manager.ts`

## Alternatives Considered

### Alternative 1: Keep Code in Index Files
**Rejected** - Makes files hard to find by name, violates discoverability principle

### Alternative 2: No Index Files (Direct Imports)
**Rejected** - Exposes internal structure, makes refactoring harder, no clear public API boundary

### Alternative 3: All Docs in README
**Rejected** - Makes README too long, hard to navigate, difficult to maintain

## Consequences

### Positive
- **Discoverability**: Ctrl+P finds actual implementation files, not dozens of "index" results
- **Clarity**: Clear separation between public API (index) and implementation
- **Navigation**: README files are useful entry points, not overwhelming documentation dumps
- **Maintainability**: Focused documentation files are easier to update
- **Searchability**: Searching codebase finds relevant code, not generic index files

### Negative
- **Initial Effort**: Requires refactoring existing code and documentation
- **More Files**: Increases total file count (but improves organization)
- **Learning Curve**: Team needs to understand the pattern

### Neutral
- **Import Statements**: No change - all imports go through index files as before
- **Build Process**: No impact on build or runtime performance

## Examples from Refactoring

### Before
```
lib/orchestrator/
  └── index.ts (296 lines - ChatOrchestrator class + types + exports)

lib/loom/
  └── README.md (266 lines - everything about Loom protocol)
```

### After
```
lib/orchestrator/
  ├── index.ts (9 lines - exports only)
  └── orchestrator.ts (288 lines - ChatOrchestrator implementation)

lib/loom/
  ├── README.md (76 lines - summary + links)
  ├── loom-protocol.md (155 lines - syntax, examples)
  ├── loom-api.md (189 lines - API reference)
  └── loom-best-practices.md (247 lines - guidelines)
```

## References

- Universal naming conventions rule
- Code quality standards
- Project architecture decision (0028)
- [Refactoring commit history](../../../../../../.git/logs/refs/heads/♻️/codebase/index-and-readme-refactor)

## Open Items

- Consider automated tooling to enforce pattern (linter rules)
- Template for new modules following this pattern
- Migration guide for existing modules not yet refactored
