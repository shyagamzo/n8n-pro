---
alwaysApply: false
description: Code quality—linting, typing, reviews, and refactoring policies for maintainability.
---

# Decision Record: n8n Extension Code Quality Standards

## Goal
Establish code quality standards and linting rules specifically for the n8n extension, ensuring consistency, maintainability, and type safety across all components.

## TypeScript Configuration
- **Strict mode enabled** - All strict TypeScript options are active
- **No implicit any** - Always provide explicit types
- **Exact optional properties** - Use `exactOptionalPropertyTypes: true`
- **No unused variables** - Remove unused imports and variables
- **Explicit return types** - Functions should have explicit return types

## ESLint/Style Rules
- **No semicolons** - Follow project style (no trailing semicolons)
- **Use single quotes** - For strings, use single quotes
- **4-space indentation** - For code, 2-space for JSON
- **Opening braces on new line** - Allman style for functions/blocks
- **Align assignments/props** - Align for readability when helpful
- **No console.log** - Use `console.warn` or `console.error` instead; never log secrets
- **Max line length** - 120 characters with exceptions for URLs and strings

### Vertical Spacing Rules

**Core Rules:**
1. Group related `const`/`let`/`var` declarations (no empty lines between them)
2. Empty line after variable group before next code block (assignments, conditions, loops, etc.)
3. Empty line before return statement (except when return is only statement in block)
4. Empty line between distinct logical operations

**Variable Declarations:**
- Group related declarations together (no empty lines between them)
- Add empty line after variable group before next code block
- Exception: Group by category with empty lines when many variables

```typescript
// ✅ CORRECT
const apiKey = config?.configurable?.openai_api_key
const modelName = config?.configurable?.model || DEFAULT_MODEL

const agent = createAgent(apiKey, modelName)
```

**Return Statements:**
- Always have empty line before return statement
- Exception: When return is the only statement in a block (if/loop)

```typescript
// ✅ CORRECT: Empty line before return
const result = await doWork()

return new Command({ update: result })

// ✅ CORRECT: No empty line when only statement
if (nextStep === END) {
  return new Command({ goto: END })
}
```

**Code Blocks:**
- Empty line between variable declarations and next code block
- Empty line between distinct logical operations

## Code Style Pattern
```typescript
// Good
function handleClick(): void
{
    setState(prev => ({ ...prev, value: newValue }))
}

// Bad
function handleClick() {
    setState(prev => {
        prev.value = newValue
        return prev
    })
}
```

## Error Handling Standards
- **Use try-catch** for async operations
- **Provide meaningful error messages**
- **Log errors** with context information
- **Handle edge cases** gracefully

### Streaming & Timeouts
- **AbortController** for timeouts on network calls
- **SSE parsing** hardened against malformed lines; ignore per-line failures
- **No secrets in logs**; sanitize error outputs

## Performance Guidelines
- **Use React.memo** for expensive components (when needed)
- **Use useCallback** for event handlers passed to children
- **Use useMemo** for expensive calculations
- **Clean up event listeners** in useEffect cleanup

## File Organization
- **One component per file** - Keep components focused
- **Use descriptive names** - Component and function names should be clear
- **Group related functionality** - Keep related code together
- **Export at the bottom** - Use default exports for main components

### Function & Helper Ordering
- **Public-first**: Primary exported API at top; helpers below
- **Decompose**: Break large functions into small, named helpers
- **Naming**: Helpers named after their purpose (e.g., `readSseStream`, `processSseChunk`)

## Comments and Documentation
- **Document complex logic** - Explain why, not what
- **Use JSDoc** for public APIs
- **Keep comments up to date** - Remove outdated comments
- **Use TODO comments** for future improvements

## n8n Extension Specific Considerations

### LangGraph Node Patterns
- **All agents as nodes** - Uniform architecture (no nested tool-agents)
- **Orchestrator owns state transitions** - Only orchestrator sets `currentStep`
- **All nodes return to orchestrator** - No hardcoded routing decisions
- **Nodes handle own logic** - Each node applies its own fixes/transformations
- **No manual logging** - Rely on reactive event system (see 0036-reactive-rxjs-architecture.mdc)

### Node File Structure (Required)
```typescript
// ==========================================
// Imports
// ==========================================

// ==========================================
// Constants
// ==========================================

// ==========================================
// Main Node
// ==========================================

// ==========================================
// Helper Functions (Configuration, Agent Creation, etc.)
// ==========================================
```

### Critical Rules for Nodes
- ✅ Use `formatLoom()` for Loom data (not JSON.stringify)
- ✅ Return to orchestrator (not other nodes)
- ✅ Update own state fields only (not `currentStep`)
- ✅ Extract helper functions (main function 10-20 lines)
- ❌ Never import `DebugSession` in nodes
- ❌ Never set `currentStep` in node updates
- ❌ Never use `session?.log()` calls
- ❌ Never bypass type system with `any`

### Type Safety for n8n
- **Type safety** for n8n API responses and workflow data
- **Error handling** for n8n API failures and network issues
- **Performance optimization** for content script injection
- **Code organization** that supports the multi-agent architecture

## Why These Standards
- **Type safety** ensures reliable operation with n8n APIs and data structures
- **Consistent code style** improves maintainability and collaboration
- **Performance guidelines** ensure responsive user experience
- **Error handling** provides robust operation in various scenarios
- **Documentation standards** support long-term maintenance and development
