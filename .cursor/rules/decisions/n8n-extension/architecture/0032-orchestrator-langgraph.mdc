# Decision: Orchestrator and Agents (LangGraph) - Full Implementation

## Context
The extension required a full multi-agent orchestrator using LangGraph for stateful, session-based workflow assistance. Initial implementation used manual orchestration without proper LangGraph patterns (StateGraph, checkpointers, tools, interrupts).

## Decision
Implement a complete LangGraph-based orchestrator with unified StateGraph, mode-based routing, LLM-based validation, and session persistence via checkpointers.

## Implementation Details

### Core Architecture
- **Unified StateGraph**: Single graph handles both chat and workflow modes
- **Mode-based routing**: Entry routing based on `state.mode` ('chat' | 'workflow')
- **Session persistence**: MemorySaver checkpointer with thread_id per session
- **Command-based control**: Nodes return `Command` for explicit routing

### Nodes (Agents)
1. **Enrichment Node** (`nodes/enrichment.ts`)
   - Conversational chat and requirement gathering
   - Uses `interrupt()` for clarification (one question at a time)
   - No tools - pure LLM interaction
   - Token streaming via callbacks
   - Markers: `[NEEDS_INPUT]`, `[READY]`, `[CHAT]`

2. **Planner Node** (`nodes/planner.ts`)
   - Generates workflow plans in Loom format
   - Tools: `fetch_n8n_node_types`, `get_node_docs`
   - Preserves Loom protocol for efficient communication
   - Events automatically captured by reactive event system

3. **Planner Tools Node** (`nodes/planner-tools.ts`)
   - Dedicated tool execution for planner
   - Uses `ToolNode` from prebuilt
   - Loops back to planner with results

4. **Validator Node** (`nodes/validator.ts`)
   - **Pure LLM-based validation** (no custom schemas)
   - Leverages LLM's knowledge of n8n
   - Auto-fixes errors by extracting corrected Loom
   - No tools - relies on LLM expertise

5. **Executor Node** (`nodes/executor.ts`)
   - Creates workflows in n8n via API tools
   - Tools: `create_n8n_workflow`, `check_credentials`
   - Non-blocking credential guidance
   - Paused via `interruptBefore: ['executor']` for approval

6. **Executor Tools Node** (`nodes/executor-tools.ts`)
   - Dedicated tool execution for executor
   - n8n API interactions
   - Loops back to executor with results

### Tool Architecture
- Each agent has dedicated tools (separation of concerns)
- Planner: n8n knowledge discovery
- Executor: n8n API operations
- Tool nodes use `ToolNode` from prebuilt
- Tools loop back to parent agent

### Callback System
- **TokenStreamHandler**: Letter-by-letter streaming for UI
- **DebugCallbackHandler**: Integration with DebugSession for detailed tracing
- **Reactive Event System**: Activity updates via SystemEvents and RxJS subscribers (see 0036-reactive-rxjs-architecture.mdc)

### Session Management
- **OrchestratorManager**: Maps session IDs to orchestrator instances
- Thread IDs: `chat-${sessionId}` and `workflow-${sessionId}`
- Cleanup on port disconnect
- Separate sessions per tab/chat panel

### Interrupts
1. **Enrichment**: `interrupt()` for clarification (conditional)
2. **Executor**: `interruptBefore` for workflow approval (always)

### Configuration
- `config.configurable`: API keys, model selection, base URLs
- `config.metadata`: Narrator, debug session (non-configurable context)
- `config.callbacks`: Token streaming, debug tracing

## Alternatives Considered
- **Two separate graphs** (chat + workflow): Rejected for unified state management
- **Supervisor node with LLM routing**: Rejected for performance (use state-based routing instead)
- **Structural validation code**: Rejected in favor of LLM-based validation
- **askHuman tool**: Rejected for direct `interrupt()` (simpler)

## Consequences

### Positive
- ✅ ~1,100 lines of legacy code removed
- ✅ Proper LangGraph patterns (StateGraph, checkpointers, tools)
- ✅ Session persistence across messages
- ✅ Two interrupt points for human-in-the-loop
- ✅ LLM-based validation (no schema maintenance)
- ✅ Non-blocking credential guidance
- ✅ Backward-compatible API

### Challenges
- Vite bundling requires Node.js module stubs for browser compatibility
- Tool typing requires casting input to avoid `unknown` type errors
- LangGraph graph routing requires type assertions for custom node names

## References
- `extension/src/ai/orchestrator/state.ts` - State schema
- `extension/src/ai/orchestrator/graph.ts` - StateGraph definition
- `extension/src/ai/orchestrator/nodes/` - Agent node implementations
- `extension/src/ai/orchestrator/tools/` - Tool definitions
- `extension/src/ai/orchestrator/entrypoint.ts` - Graph execution entry point
- `extension/src/entries/background/background-worker.ts` - Background orchestration
- Decisions: 0007, 0025, 0012, 0021, 0011, 0027

