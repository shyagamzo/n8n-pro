---
alwaysApply: false
description: Coding standardsâ€”TypeScript strictness, formatting, imports, naming, and refactoring guidance.
---

# Decision Record: n8n Extension Coding Standards

## n8n Extension Specific Standards

### Package Manager & Build Tools
- **yarn**: Use yarn for package management
- **Vite**: Build tool with TypeScript and React support
- **Node.js 22**: Latest LTS version

### Language & Framework Choices
- **TypeScript**: Strict mode enabled, 5.9.x
- **React**: 19.x for UI components
- **Zustand**: 5.x for state management
- **LangChainJS**: 0.3.x for AI orchestration

### n8n Extension Specific Formatting
- **4 spaces** for indentation (except .json files)
- **2 spaces** for .json file indentation
- **No Prettier**: Custom styling rules to be defined later

### n8n Extension Import Organization
Imports should follow this order:
1. **Low-level packages** (e.g., `lodash`, `rxjs`)
2. **Framework packages** (e.g., `react`, `@types/chrome`)
3. **Third-party libraries** (e.g., `@langchain/openai`, `zustand`)
4. **Internal imports** (separated by one empty line)

### Separation of Concerns (Extension)
- **Content scripts are thin**: Only mount UI, toggle panel, and detect host page. No business logic.
- **Background owns platform APIs**: Chrome runtime, storage, and network calls live behind services.
- **Services**: Wrap Chrome ports/messaging and API calls; expose typed methods (no DOM/React here).
- **Containers**: Bind services/state to presentational components.
- **Presentational components**: UI only; no side-effects or platform calls.
- **Styles**: Use co-located CSS files (`.css`) next to components; apply via `className` prop.

### Component Styling Standards
- **CSS files co-located with components** - Create `.css` file next to each `.tsx` component file
- **Use CSS classes** - Apply styles via `className` prop, not inline styles
- **Design tokens with fallbacks** - Use n8n's CSS variables: `var(--color-primary, #ff6d5a)`
- **Shared CSS for common patterns** - Group related component styles (e.g., `FormElements.css`)
- **Only dynamic styles inline** - Use `style` prop only for runtime-calculated values (positioning, sizing)
- **BEM-like naming** - Use clear, scoped class names: `.component-name`, `.component-name--modifier`

### Import Alignment
- Align imports vertically to the furthest closing bracket
- Internal imports ordered from least close to closest

### Object Properties & Assignment Alignment
- Align variable assignments and object properties vertically
- Use consistent spacing for readability

### Braces & Control Structures
- **Opening braces on new line** for functions and control structures
- Consistent indentation with 4 spaces

### Switch Statements
- **Avoid switch statements** when possible, use mapping objects
- Use type-alias based (union type) routing for agent types (Classifier, Enrichment, Planner, Executor)

### Line Grouping
Separate lines into logical groups:
- **Assignments**
- **Control blocks content** (loops, conditions)
- **Return statements**
- **Same-topic operations**


## TypeScript Standards

### Type Safety
- **Strong typing**: Type all variables whenever possible
- **Return types**: Always state return type of functions/methods
- **Strict mode**: Enable strict TypeScript configuration

### Function Design
- **Break complex functions** into smaller, meaningful functions
- **Meaningful names**: Use descriptive and explanatory names
- **Single responsibility**: Each function should do one thing well
- **Reusable Units**: Design functions to be reusable across different contexts
- **Clear Boundaries**: Functions should have clear input/output contracts
- **No Side Effects**: Prefer pure functions when possible

### Readable Control Flow (Critical)

**Principle:** Code should read like English. "If X, then doThis()" - not "If X, then inline 20 lines of logic"

**BAD - Unreadable compound blocks:**
```typescript
if (message.type === 'error')
{
  setAssistantDraft('')
  setPendingPlan(null)
  finishSending()

  const errorDetails: ErrorDetails = {
    title: this.getErrorTitle(message.error),
    details: this.getErrorDetails(message.error),
    retryable: this.isRetryable(message.error),
    retryPayload: this.isRetryable(message.error)
      ? { messages: this.lastSentMessages }
      : undefined
  }

  addMessage({
    id: generateId(),
    role: 'error',
    text: this.getErrorMessage(message.error),
    error: errorDetails
  })
}
// ^ What's the mission here? Have to read all 20 lines to understand!
```

**GOOD - Readable with extracted handlers:**
```typescript
// Main handler reads like English
if (message.type === 'error') this.handleError(message)

// Handler has clear, self-documenting mission
private handleError(message: { type: 'error'; error: string }): void
{
  const { setAssistantDraft, setPendingPlan, finishSending, addMessage } = useChatStore.getState()

  setAssistantDraft('')
  setPendingPlan(null)
  finishSending()

  const errorDetails = this.buildErrorDetails(message.error)
  addMessage(this.createErrorMessage(message.error, errorDetails))
}
```

**Rules:**
1. **If block > 5 lines**: Extract to named function
2. **If block has "mission"**: Extract to function named after mission
3. **Main control flow**: Should read like table of contents
4. **Handler functions**: Should have clear, action-oriented names
5. **No nested blocks**: Keep nesting shallow with early returns

**Examples:**
- âœ… `if (isReady) handleReady()` - Clear mission
- âœ… `if (error) handleError(error)` - Self-documenting
- âœ… `if (token) appendToken(token)` - Obvious intent
- âŒ `if (error) { /* 30 lines */ }` - Unreadable
- âŒ `if (x) { if (y) { if (z) { /* nested */ }}}` - Too complex

**Message/Event Handlers Pattern (Preferred: Map-Based Router):**
```typescript
// âœ… BEST - Map-based router (no if-else chains)
private messageHandlers: Record<string, (msg: any) => void> = {
  create: (msg) => this.handleCreate(msg),
  update: (msg) => this.handleUpdate(msg),
  delete: (msg) => this.handleDelete(msg),
}

onMessage(message: Message): void
{
  this.messageHandlers[message.type]?.(message)
}

private handleCreate(message: CreateMessage): void { /* focused logic */ }
private handleUpdate(message: UpdateMessage): void { /* focused logic */ }
private handleDelete(message: DeleteMessage): void { /* focused logic */ }
```

**Why Map-Based Router:**
- âœ… No if-else chains to read through
- âœ… Single line dispatch: `handlers[type]?.(msg)`
- âœ… Easy to add new handlers (just add to map)
- âœ… Self-documenting (map shows all message types)
- âœ… Type-safe with proper typing

**Avoid:**
- âŒ Long if-else chains
- âŒ Switch statements (verbose)
- âŒ Inline logic in routing code

## File & Folder Structure

### Project Organization (Separation of Concerns)
```
src/
â”œâ”€â”€ background/          # Service worker (orchestration layer)
â”œâ”€â”€ content/            # Content scripts (injection layer)
â”œâ”€â”€ panel/              # React panel UI (presentation layer)
â”œâ”€â”€ options/            # Options page (configuration layer)
â”œâ”€â”€ lib/                # Shared utilities (business logic layer)
â”‚   â”œâ”€â”€ api/           # API clients (data access layer)
â”‚   â”œâ”€â”€ agents/        # AI agents (business logic layer)
â”‚   â”œâ”€â”€ components/    # Shared components (presentation layer)
â”‚   â”œâ”€â”€ services/      # Business services (business logic layer)
â”‚   â”œâ”€â”€ models/        # Data models (data layer)
â”‚   â”œâ”€â”€ utils/         # Pure utilities (utility layer)
â”‚   â””â”€â”€ types/         # TypeScript types (contract layer)
â””â”€â”€ __tests__/         # Test files (testing layer)
```

### Architectural Layers
- **Presentation Layer**: UI components, panels, options pages
- **Business Logic Layer**: Agents, services, workflow orchestration
- **Data Access Layer**: API clients, storage, external integrations
- **Data Layer**: Models, types, data structures
- **Utility Layer**: Pure functions, helpers, validators
- **Configuration Layer**: Settings, environment, constants

### Naming Conventions
- **Files**: kebab-case (e.g., `chat-panel.tsx`)
- **Components**: PascalCase (e.g., `ChatPanel`)
- **Functions/Variables**: camelCase (e.g., `createWorkflow`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_BASE_URL`)
- **Types/Interfaces**: PascalCase (e.g., `WorkflowConfig`)

## Testing Strategy

### Unit Testing
- **Test public API only**
- **Test expected behavior**, not implementation
- **Meaningful test names**: Describe what is being tested
- **Small, focused tests**: One concept per test

### Test Structure
- Use AAA pattern (Arrange, Act, Assert)
- Test public APIs only, not implementation details
- Focus on behavior and expected outcomes

## Error Handling & Logging

### Error Handling
- **Graceful degradation**: Handle errors without crashing
- **User-friendly messages**: Clear error messages for users
- **Logging**: Log errors for debugging (no sensitive data)

### Logging Strategy
- Use structured logging with consistent format
- Include error levels (ERROR, INFO, DEBUG)
- Only log debug information in development mode

## State Management

### Zustand Patterns
- **Small, focused stores**: One store per domain
- **Immutable updates**: Use immer for complex state updates
- **Type safety**: Strongly typed store interfaces

- Define clear interfaces for store state and actions
- Use immutable updates for state changes
- Keep stores focused on single domains

## API & Data Layer

### HTTP Client
- **Custom fetch wrapper**: Tailored to extension needs
- **Error handling**: Consistent error handling across API calls
- **Type safety**: Strongly typed request/response interfaces

### Data Validation
- **Input validation**: Validate all user inputs
- **Response validation**: Validate API responses
- **Type guards**: Use type guards for runtime type checking

## Documentation Standards

### Inline Documentation
- **JSDoc style**: Document all public APIs
- **Explain "why"**: Provide context and reasoning
- **Examples**: Include usage examples where helpful

```typescript
/**
 * Creates a new workflow based on user description
 * @param description - Natural language description of the workflow
 * @param options - Optional configuration for workflow creation
 * @returns Promise resolving to the created workflow
 * @throws {ValidationError} When description is invalid
 * @example
 * ```typescript
 * const workflow = await createWorkflow('Send email when form submitted');
 * ```
 */
async function createWorkflow(
    description: string,
    options?: WorkflowOptions
): Promise<Workflow>
{
    // Implementation
}
```

### README Structure
- **TLDR Summary**: Quick overview at the top
- **Installation**: Clear setup instructions
- **Usage**: Examples and common patterns
- **API Reference**: Link to detailed documentation

## Git Workflow & CI/CD

### Commit Standards
- **Small, precise commits**: One logical change per commit
- **Emoji prefixes**: Use relevant emojis for commit types
- **Descriptive messages**: Answer "what did you do?"

### Commit Emoji Map
| Emoji | Use when... |
|-------|-------------|
| âœ¨ | Scaffolded new component/service |
| ğŸ› | Fixed a bug |
| â• | Added new feature |
| â– | Removed feature |
| â™»ï¸ | Refactored code |
| ğŸ¨ | Improved code structure |
| âš¡ | Performance optimization |
| ğŸ“ƒ | Documentation changes |
| ğŸ”§ | Configuration changes |
| ğŸ’„ | UI/styling improvements |
| ğŸ“¦ | Dependency updates |
| âœ… | Added/modified tests |
| ğŸ¤– | AI instructions, Cursor rules, agent configurations |
| ğŸ’­ | Decisions, brainstorms, planning documentation |
| ğŸ³ | Docker, DevContainer, or container related |

### Branch Naming
- **Format**: `<emoji>/<module>/<feature-name>`
- **Example**: `â•/panel/chat-interface`

## Refactoring Guidelines

### When to Refactor
- **Large Files**: When files exceed ~300 lines, consider breaking them down
- **Before Adding Features**: Examine if new functionality fits existing structure
- **After Bug Fixes**: If bug reveals structural issues, refactor to prevent recurrence
- **Code Smells**: Duplicate code, long parameter lists, complex conditionals

### Refactoring Process
1. **Identify the Problem**: What is the root cause?
2. **Plan the Refactor**: How can we improve the structure?
3. **Extract Reusable Units**: Break down into smaller, focused modules
4. **Separate Concerns**: Move logic out of view components
5. **Test Thoroughly**: Ensure functionality remains intact

### Anti-Patterns to Avoid
- **Patching**: Quick fixes that don't address root causes
- **God Objects**: Classes/components that do too much
- **Tight Coupling**: Dependencies that make testing and reuse difficult
- **Mixed Concerns**: Business logic mixed with presentation logic
- **Leaky Abstractions**: Implementation details leaking through interfaces
- **Circular Dependencies**: Modules depending on each other in cycles
- **Fat Controllers**: Components handling too many responsibilities
- **Service Locators**: Hidden dependencies and global state

## Open Items
- **ESLint Configuration**: Define specific ESLint rules
- **Custom Styling Rules**: Define formatting rules (no Prettier)
- **CI/CD Pipeline**: GitHub Actions configuration
- **Code Review Process**: Review guidelines and checklist
