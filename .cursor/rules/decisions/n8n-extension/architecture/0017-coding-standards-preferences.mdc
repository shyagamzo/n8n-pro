---
alwaysApply: false
description: Coding standards‚ÄîTypeScript strictness, formatting, imports, naming, and refactoring guidance.
---

# Decision Record: n8n Extension Coding Standards

## n8n Extension Specific Standards

### Package Manager & Build Tools
- **yarn**: Use yarn for package management
- **Vite**: Build tool with TypeScript and React support
- **Node.js 22**: Latest LTS version

### Language & Framework Choices
- **TypeScript**: Strict mode enabled, 5.9.x
- **React**: 19.x for UI components
- **Zustand**: 5.x for state management
- **LangChainJS**: 0.3.x for AI orchestration

### n8n Extension Specific Formatting
- **4 spaces** for indentation (except .json files)
- **2 spaces** for .json file indentation
- **No Prettier**: Custom styling rules to be defined later

### n8n Extension Import Organization
Imports should follow this order:
1. **Low-level packages** (e.g., `lodash`, `rxjs`)
2. **Framework packages** (e.g., `react`, `@types/chrome`)
3. **Third-party libraries** (e.g., `@langchain/openai`, `zustand`)
4. **Internal imports** (separated by one empty line)

### Separation of Concerns (Extension)
- **Content scripts are thin**: Only mount UI, toggle panel, and detect host page. No business logic.
- **Background owns platform APIs**: Chrome runtime, storage, and network calls live behind services.
- **Services**: Wrap Chrome ports/messaging and API calls; expose typed methods (no DOM/React here).
- **Containers**: Bind services/state to presentational components.
- **Presentational components**: UI only; no side-effects or platform calls.
- **Styles**: Use co-located CSS files (`.css`) next to components; apply via `className` prop.

### Component Styling Standards
- **CSS files co-located with components** - Create `.css` file next to each `.tsx` component file
- **Use CSS classes** - Apply styles via `className` prop, not inline styles
- **Design tokens with fallbacks** - Use n8n's CSS variables: `var(--color-primary, #ff6d5a)`
- **Shared CSS for common patterns** - Group related component styles (e.g., `FormElements.css`)
- **Only dynamic styles inline** - Use `style` prop only for runtime-calculated values (positioning, sizing)
- **BEM-like naming** - Use clear, scoped class names: `.component-name`, `.component-name--modifier`

### Import Alignment
- Align imports vertically to the furthest closing bracket
- Internal imports ordered from least close to closest

### Object Properties & Assignment Alignment
- Align variable assignments and object properties vertically
- Use consistent spacing for readability

### Braces & Control Structures
- **Opening braces on new line** for functions and control structures
- Consistent indentation with 4 spaces

### Switch Statements
- **Avoid switch statements** when possible, use mapping objects
- Use type-alias based (union type) routing for agent types (Classifier, Enrichment, Planner, Executor)

### Line Grouping
Separate lines into logical groups:
- **Assignments**
- **Control blocks content** (loops, conditions)
- **Return statements**
- **Same-topic operations**


## TypeScript Standards

### Type Safety
- **Strong typing**: Type all variables whenever possible
- **Return types**: Always state return type of functions/methods
- **Strict mode**: Enable strict TypeScript configuration

### Function Design
- **Break complex functions** into smaller, meaningful functions
- **Meaningful names**: Use descriptive and explanatory names
- **Single responsibility**: Each function should do one thing well
- **Reusable Units**: Design functions to be reusable across different contexts
- **Clear Boundaries**: Functions should have clear input/output contracts
- **No Side Effects**: Prefer pure functions when possible

## File & Folder Structure

### Project Organization (Separation of Concerns)
```
src/
‚îú‚îÄ‚îÄ background/          # Service worker (orchestration layer)
‚îú‚îÄ‚îÄ content/            # Content scripts (injection layer)
‚îú‚îÄ‚îÄ panel/              # React panel UI (presentation layer)
‚îú‚îÄ‚îÄ options/            # Options page (configuration layer)
‚îú‚îÄ‚îÄ lib/                # Shared utilities (business logic layer)
‚îÇ   ‚îú‚îÄ‚îÄ api/           # API clients (data access layer)
‚îÇ   ‚îú‚îÄ‚îÄ agents/        # AI agents (business logic layer)
‚îÇ   ‚îú‚îÄ‚îÄ components/    # Shared components (presentation layer)
‚îÇ   ‚îú‚îÄ‚îÄ services/      # Business services (business logic layer)
‚îÇ   ‚îú‚îÄ‚îÄ models/        # Data models (data layer)
‚îÇ   ‚îú‚îÄ‚îÄ utils/         # Pure utilities (utility layer)
‚îÇ   ‚îî‚îÄ‚îÄ types/         # TypeScript types (contract layer)
‚îî‚îÄ‚îÄ __tests__/         # Test files (testing layer)
```

### Architectural Layers
- **Presentation Layer**: UI components, panels, options pages
- **Business Logic Layer**: Agents, services, workflow orchestration
- **Data Access Layer**: API clients, storage, external integrations
- **Data Layer**: Models, types, data structures
- **Utility Layer**: Pure functions, helpers, validators
- **Configuration Layer**: Settings, environment, constants

### Naming Conventions
- **Files**: kebab-case (e.g., `chat-panel.tsx`)
- **Components**: PascalCase (e.g., `ChatPanel`)
- **Functions/Variables**: camelCase (e.g., `createWorkflow`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_BASE_URL`)
- **Types/Interfaces**: PascalCase (e.g., `WorkflowConfig`)

## Testing Strategy

### Unit Testing
- **Test public API only**
- **Test expected behavior**, not implementation
- **Meaningful test names**: Describe what is being tested
- **Small, focused tests**: One concept per test

### Test Structure
- Use AAA pattern (Arrange, Act, Assert)
- Test public APIs only, not implementation details
- Focus on behavior and expected outcomes

## Error Handling & Logging

### Error Handling
- **Graceful degradation**: Handle errors without crashing
- **User-friendly messages**: Clear error messages for users
- **Logging**: Log errors for debugging (no sensitive data)

### Logging Strategy
- Use structured logging with consistent format
- Include error levels (ERROR, INFO, DEBUG)
- Only log debug information in development mode

## State Management

### Zustand Patterns
- **Small, focused stores**: One store per domain
- **Immutable updates**: Use immer for complex state updates
- **Type safety**: Strongly typed store interfaces

- Define clear interfaces for store state and actions
- Use immutable updates for state changes
- Keep stores focused on single domains

## API & Data Layer

### HTTP Client
- **Custom fetch wrapper**: Tailored to extension needs
- **Error handling**: Consistent error handling across API calls
- **Type safety**: Strongly typed request/response interfaces

### Data Validation
- **Input validation**: Validate all user inputs
- **Response validation**: Validate API responses
- **Type guards**: Use type guards for runtime type checking

## Documentation Standards

### Inline Documentation
- **JSDoc style**: Document all public APIs
- **Explain "why"**: Provide context and reasoning
- **Examples**: Include usage examples where helpful

```typescript
/**
 * Creates a new workflow based on user description
 * @param description - Natural language description of the workflow
 * @param options - Optional configuration for workflow creation
 * @returns Promise resolving to the created workflow
 * @throws {ValidationError} When description is invalid
 * @example
 * ```typescript
 * const workflow = await createWorkflow('Send email when form submitted');
 * ```
 */
async function createWorkflow(
    description: string, 
    options?: WorkflowOptions
): Promise<Workflow>
{
    // Implementation
}
```

### README Structure
- **TLDR Summary**: Quick overview at the top
- **Installation**: Clear setup instructions
- **Usage**: Examples and common patterns
- **API Reference**: Link to detailed documentation

## Git Workflow & CI/CD

### Commit Standards
- **Small, precise commits**: One logical change per commit
- **Emoji prefixes**: Use relevant emojis for commit types
- **Descriptive messages**: Answer "what did you do?"

### Commit Emoji Map
| Emoji | Use when... |
|-------|-------------|
| ‚ú® | Scaffolded new component/service |
| üêõ | Fixed a bug |
| ‚ûï | Added new feature |
| ‚ûñ | Removed feature |
| ‚ôªÔ∏è | Refactored code |
| üé® | Improved code structure |
| ‚ö° | Performance optimization |
| üìÉ | Documentation changes |
| üîß | Configuration changes |
| üíÑ | UI/styling improvements |
| üì¶ | Dependency updates |
| ‚úÖ | Added/modified tests |
| ü§ñ | AI instructions, Cursor rules, agent configurations |
| üí≠ | Decisions, brainstorms, planning documentation |
| üê≥ | Docker, DevContainer, or container related |

### Branch Naming
- **Format**: `<emoji>/<module>/<feature-name>`
- **Example**: `‚ûï/panel/chat-interface`

## Refactoring Guidelines

### When to Refactor
- **Large Files**: When files exceed ~300 lines, consider breaking them down
- **Before Adding Features**: Examine if new functionality fits existing structure
- **After Bug Fixes**: If bug reveals structural issues, refactor to prevent recurrence
- **Code Smells**: Duplicate code, long parameter lists, complex conditionals

### Refactoring Process
1. **Identify the Problem**: What is the root cause?
2. **Plan the Refactor**: How can we improve the structure?
3. **Extract Reusable Units**: Break down into smaller, focused modules
4. **Separate Concerns**: Move logic out of view components
5. **Test Thoroughly**: Ensure functionality remains intact

### Anti-Patterns to Avoid
- **Patching**: Quick fixes that don't address root causes
- **God Objects**: Classes/components that do too much
- **Tight Coupling**: Dependencies that make testing and reuse difficult
- **Mixed Concerns**: Business logic mixed with presentation logic
- **Leaky Abstractions**: Implementation details leaking through interfaces
- **Circular Dependencies**: Modules depending on each other in cycles
- **Fat Controllers**: Components handling too many responsibilities
- **Service Locators**: Hidden dependencies and global state

## Open Items
- **ESLint Configuration**: Define specific ESLint rules
- **Custom Styling Rules**: Define formatting rules (no Prettier)
- **CI/CD Pipeline**: GitHub Actions configuration
- **Code Review Process**: Review guidelines and checklist
